@using LANCommander.Launcher.Data.Models
@using LANCommander.SDK.Extensions
@namespace LANCommander.Launcher.UI
@inherits FeedbackComponent<Models.ListItem, string>
@inject InstallService InstallService
@inject ToolService ToolService
@inject LocalizationService LocalizationService
@inject GameClient GameClient
@inject ISettingsProvider SettingsProvider

<div style="padding: 16px;">
    <Row Gutter="16">
        <Col Span="12">
            <Statistic Title="@LocalizationService.GetString("DownloadSize")" Value="@ByteSizeLib.ByteSize.FromBytes(GetDownloadSize()).ToString()" Style="text-align: center;"/>
        </Col>
        <Col Span="12">
            <Statistic Title="@LocalizationService.GetString("SpaceRequired")" Value="@ByteSizeLib.ByteSize.FromBytes(GetSpaceRequired()).ToString()" Style="text-align: center;"/>
        </Col>
    </Row>


    @if (Addons.Any())
    {
        <Divider Text="@LocalizationService.GetString("Addons")" />

        <CheckboxButtonGroup @bind-Selected="SelectedAddons" DataSource="Addons" KeySelector="a => a.Id" LabelSelector="a => a.Title" Direction="SpaceDirection.Vertical" />
    }
    
    @if (Tools.Any())
    {
        <Divider Text="@LocalizationService.GetString("Tools")" />
        
        <CheckboxButtonGroup @bind-Selected="SelectedTools" DataSource="Tools" KeySelector="t => t.Id" LabelSelector="t => t.Name" Direction="SpaceDirection.Vertical" />
    }

    @if (SettingsProvider.CurrentValue.Games.InstallDirectories.Length > 1)
    {
        <Divider Text="@LocalizationService.GetString("InstallLocation")" />
        <RadioGroup @bind-Value="SelectedDirectory" ButtonStyle="RadioButtonStyle.Solid" Size="InputSize.Large" Class="install-dialog-directory-selector radio-group-vertical radio-group-block">
            @foreach (var directory in SettingsProvider.CurrentValue.Games.InstallDirectories)
            {
                <Radio RadioButton Value="@directory">
                    <GridRow>
                        <GridCol Flex="@("auto")">
                            @directory
                        </GridCol>
                        <GridCol>
                            <ByteSize Value="GetFreeSpace(directory)" />
                        </GridCol>
                    </GridRow>
                </Radio>
            }
        </RadioGroup>
    }
</div>


<Flex Gap="FlexGap.Middle" Style="padding: 16px; padding-top: 0px" Justify="FlexJustify.FlexEnd">
    @if (GetOperation() != "None")
    {
        <Button Type="ButtonType.Primary" OnClick="Install">@LocalizationService.GetString(GetOperation())</Button>
    }

    <Button OnClick="() => Close()">@LocalizationService.GetString("Close")</Button>
</Flex>

@code {
    string SelectedDirectory = "";

    SDK.Models.Game RemoteGame;
    Data.Models.Game Game;

    List<SDK.Models.Game> Addons = new();
    IEnumerable<SDK.Models.Game> SelectedAddons = new List<SDK.Models.Game>();

    List<SDK.Models.Tool> Tools = new();
    IEnumerable<SDK.Models.Tool> SelectedTools = new List<SDK.Models.Tool>();

    protected override async Task OnInitializedAsync()
    {
        Game = Options.DataItem as Game;

        if (Game.Installed)
            SelectedDirectory = SettingsProvider.CurrentValue.Games.InstallDirectories.FirstOrDefault(d => Game.InstallDirectory.StartsWith(d));

        if (String.IsNullOrWhiteSpace(SelectedDirectory))
            SelectedDirectory = SettingsProvider.CurrentValue.Games.InstallDirectories.First();

        RemoteGame = await GameClient.GetAsync(Options.Key);

        await LoadAddons();
        await LoadTools();

        var localAddons = Game?.DependentGames.Where(g => g.Installed).Select(addon => addon.Id).ToArray() ?? [];
        SelectedAddons = Addons?.Where(addon => localAddons.Contains(addon.Id)).ToList() ?? [];

        var localTools = Game?.Tools.Where(t => t.Installed).Select(tool => tool.Id).ToArray() ?? [];
        SelectedTools = Tools?.Where(tool => localTools.Contains(tool.Id)).ToList() ?? [];
    }

    async Task LoadAddons()
    {
        try
        {
            Addons = (await GameClient.GetAddonsAsync(Options.Key)).OrderByTitle(g => g.SortTitle ?? g.Title).ToList();
        }
        catch (Exception ex)
        {
            // TODO: Add logging
            Addons = [];
        }
    }

    async Task LoadTools()
    {
        try
        {
            Tools = (await GameClient.GetToolsAsync(Options.Key)).OrderByTitle(t => t.Name).ToList();
        }
        catch (Exception ex)
        {
            // TODO: Add logging
            Tools = [];
        }
    }

    async Task Close()
    {
        await CloseFeedbackAsync();
    }

    async Task Install()
    {
        var game = Options.DataItem as Game;

        await InstallService.Add(game, SelectedDirectory, SelectedAddons.ToArray());

        foreach (var tool in SelectedTools)
        {
            
            await InstallService.Add(tool, SelectedDirectory);
        }

        await CloseFeedbackAsync();
    }

    string GetOperation()
    {
        if (!Game.Installed)
            return "Install";

        if (Game.DependentGames.Any(g => g.Installed ^ SelectedAddons.Any(a => a.Id == g.Id)))
            return "Modify";

        if (!Game.InstallDirectory.StartsWith(SelectedDirectory))
            return "Move";

        return string.Empty;
    }

    long GetDownloadSize()
    {
        long size = 0;

        if (RemoteGame != null && RemoteGame.Archives.Any())
        {
            size += RemoteGame.Archives.OrderByDescending(a => a.CreatedOn).First().CompressedSize;

            size += SelectedAddons.Sum(a => a.Archives.OrderByDescending(arc => arc.CreatedOn).First().CompressedSize);

            size += SelectedTools.Sum(t => t.Archives.OrderByDescending(arc => arc.CreatedOn).First().CompressedSize);
        }

        return size;
    }

    long GetSpaceRequired()
    {
        long size = 0;

        if (RemoteGame != null && RemoteGame.Archives.Any())
        {
            size += RemoteGame.Archives.OrderByDescending(a => a.CreatedOn).First().UncompressedSize;

            size += SelectedAddons.Sum(a => a.Archives.OrderByDescending(arc => arc.CreatedOn).First().UncompressedSize);

            size += SelectedTools.Sum(t => t.Archives.OrderByDescending(arc => arc.CreatedOn).First().UncompressedSize);
        }

        return size;
    }

    long GetFreeSpace(string path)
    {
        var root = Path.GetPathRoot(path);
        var drive = new DriveInfo(path);

        return drive.AvailableFreeSpace;
    }
}