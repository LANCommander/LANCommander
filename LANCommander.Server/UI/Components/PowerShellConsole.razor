@using LANCommander.SDK.PowerShell
@using LANCommander.SDK.Services
@using LANCommander.Server.Services.PowerShell
@using XtermBlazor
@using LogLevel = Microsoft.Extensions.Logging.LogLevel
@inject ScriptDebugger ScriptDebugger
@inject ScriptClient ScriptClient
@inject GameService GameService

<div class="terminal @(Active ? "" : "hidden")">
    <Xterm @ref="Terminal" Id="@Id.ToString()" Options="_options" OnFirstRender="@OnFirstRender" Addons="@Addons" />
</div>

@code {
    [Parameter] public Guid Id { get; set; }
    [Parameter] public bool Active { get; set; }
    [Parameter] public EventCallback<bool> ActiveChanged { get; set; }
    
    private Xterm Terminal;
    private TaskCompletionSource<string> InputTaskCompletionSource;

    private TerminalOptions _options = new()
    {
        CursorBlink = true,
        CursorStyle = CursorStyle.Bar,
    };

    private HashSet<string> Addons = new()
    {
        "readline",
        "addon-fit"
    };

    private async Task OnFirstRender()
    {
        await Terminal.Addon("addon-fit").InvokeVoidAsync("fit");
    }

    private async Task<string> ReadLine()
    {
        return await Terminal.Addon("readline").InvokeAsync<string>("read", "> ");
    }

    async Task SetActive(bool active)
    {
        Active = active;

        if (ActiveChanged.HasDelegate)
            await ActiveChanged.InvokeAsync(Active);
    } 

    public async Task DebugPackagingScript(Guid gameId)
    {
        ScriptDebugger.OnBreak = Break;
        ScriptDebugger.OnStart = Start;
        ScriptDebugger.OnEnd = End;
        ScriptDebugger.OnOutput = Output;

        ScriptClient.Debug = true;

        await GameService.PackageAsync(gameId);
    }

    public async Task Start(IScriptDebugContext context)
    {
        Terminal?.Clear();
        await SetActive(true);
        await InvokeAsync(StateHasChanged);

        await Terminal.Focus();
        await Terminal.Addon("addon-fit").InvokeVoidAsync("fit");
    }

    public async Task End(IScriptDebugContext context)
    {
        await SetActive(false);
        await InvokeAsync(StateHasChanged);
    }

    public async Task Break(IScriptDebugContext context)
    {
        while (true)
        {
            var input = await ReadLine();

            if (input.Trim().Equals("exit", StringComparison.OrdinalIgnoreCase))
                break;

            if (input.StartsWith('$'))
                input = "Write-Host " + input;

            await context.ExecuteAsync(input);
        }
    }

    public async Task Output(IScriptDebugContext context, LogLevel level, string message)
    {
        try
        {
            switch (level)
            {
                case LogLevel.Error:
                    await Terminal.WriteLine($"\x1b[0;31m{message}");
                    break;

                case LogLevel.Warning:
                    await Terminal.WriteLine($"\x1b[0;33m{message}");
                    break;

                case LogLevel.Debug:
                    await Terminal.WriteLine($"\x1b[0;37m{message}");
                    break;

                case LogLevel.Trace:
                    await Terminal.WriteLine($"\x1b[0;36m{message}");
                    break;

                case LogLevel.Information:
                    await Terminal.WriteLine($"\x1b[0;37m{message}");
                    break;
            }
        }
        catch (Exception ex)
        {
            
        }
    }
}