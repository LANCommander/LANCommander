@using LANCommander.SDK
@using LANCommander.SDK.PowerShell
@using XtermBlazor
@using LogLevel = Microsoft.Extensions.Logging.LogLevel
@inject Client Client
@namespace LANCommander.UI.Components

<div class="terminal @(Visible ? "" : "hidden")">
    <Xterm @ref="Terminal" Options="_options" OnFirstRender="@OnFirstRender" Addons="@Addons" />
</div>

@code {
    [Parameter] public PowerShellDebugHandler DebugHandler { get; set; }
    [Parameter] public Guid? SessionId { get; set; }
    
    private bool Visible { get; set; } = false;
    private Xterm Terminal;
    private TaskCompletionSource<string> InputTaskCompletionSource;

    private TerminalOptions _options = new()
    {
        CursorBlink = true,
        CursorStyle = CursorStyle.Bar,
    };

    private HashSet<string> Addons = new()
    {
        "readline",
        "addon-fit"
    };

    protected override void OnInitialized()
    {
        if (SessionId != null)
            DebugHandler = Client.Scripts.GetDebugHandler(SessionId.Value);
            
        DebugHandler.OnDebugStart += OnDebugStart;
        DebugHandler.OnDebugBreak += OnDebugBreak;
        DebugHandler.OnDebugOutput += OnDebugOutput;
    }

    private async void OnDebugStart(object? sender, OnDebugStartEventArgs e)
    {
        Terminal?.Clear();
        Visible = true;
        await InvokeAsync(StateHasChanged);

        await Terminal.Addon("addon-fit").InvokeVoidAsync("fit");
    }

    private async void OnDebugBreak(object? sender, OnDebugBreakEventArgs e)
    {
        while (true)
        {
            var input = await ReadLine();

            if (input.Trim().Equals("exit", StringComparison.OrdinalIgnoreCase))
                break;

            await DebugHandler.ExecuteAsync(input);
        }

        Visible = false;
        await InvokeAsync(StateHasChanged);
    }

    private async void OnDebugOutput(object? sender, OnDebugOutputEventArgs e)
    {
        switch (e.LogLevel)
        {
            case LogLevel.Error:
                await Terminal.WriteLine($"\x1b[0;31m{e.Message}");
                break;

            case LogLevel.Warning:
                await Terminal.WriteLine($"\x1b[0;33m{e.Message}");
                break;

            case LogLevel.Debug:
                await Terminal.WriteLine($"\x1b[0;37m{e.Message}");
                break;

            case LogLevel.Trace:
                await Terminal.WriteLine($"\x1b[0;36m{e.Message}");
                break;

            case LogLevel.Information:
                await Terminal.WriteLine($"\x1b[0;37m{e.Message}");
                break;
        }
    }

    private async Task OnFirstRender()
    {
        await Terminal.Addon("addon-fit").InvokeVoidAsync("fit");
    }

    private async Task<string> ReadLine()
    {
        return await Terminal.Addon("readline").InvokeAsync<string>("read", "> ");
    }
}